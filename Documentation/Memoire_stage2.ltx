\documentclass[12pt,a4paper]{report}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}

\lstdefinelanguage{Coq}{ 
%
% Anything betweeen $ becomes LaTeX math mode
mathescape=true,
%
% Comments may or not include Latex commands
texcl=false, 
%
% Vernacular commands
morekeywords=[1]{Section, Module, End, Require, Import, Export,
  Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
  Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
  Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
  Morphism, Relation, Implicit, Arguments, Unset, Contextual,
  Strict, Prenex, Implicits, Inductive, CoInductive, Record,
  Structure, Canonical, Coercion, Context, Class, Global, Instance,
  Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
  Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
  Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
  Projections, inside, outside, Def},
%
% Gallina
morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
  match, with, end, as, in, return, let, if, is, then, else, for, of,
  nosimpl, when},
%
% Sorts
morekeywords=[3]{Type, Prop, Set, true, false, option},
%
% Various tactics, some are std Coq subsumed by ssr, for the manual purpose
morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
  intro, intros, generalize, rename, pattern, after, destruct,
  induction, using, refine, inversion, injection, rewrite, congr,
  unlock, compute, ring, field, fourier, replace, fold, unfold,
  change, cutrewrite, simpl, have, suff, wlog, suffices, without,
  loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
  symmetry, transitivity, auto, split, left, right, autorewrite},
%
% Terminators
morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
  assumption, solve, contradiction, discriminate},
%
% Control
morekeywords=[6]{do, last, first, try, idtac, repeat},
%
% Comments delimiters, we do turn this off for the manual
morecomment=[s]{(*}{*)},
%
% Spaces are not displayed as a special character
showstringspaces=false,
%
% String delimiters
morestring=[b]",
morestring=[d]’,
%
% Size of tabulations
tabsize=2,
%
% Enables ASCII chars 128 to 255
extendedchars=false,
%
% Case sensitivity
sensitive=true,
%
% Automatic breaking of long lines
breaklines=false,
%
% Default style fors listings
basicstyle=\small,
%
% Position of captions is bottom
captionpos=b,
%
% flexible columns
columns=[l]flexible,
%
% Style for (listings') identifiers
identifierstyle={\ttfamily\color{black}},
% Style for declaration keywords
keywordstyle=[1]{\ttfamily\color{violet}},
% Style for gallina keywords
keywordstyle=[2]{\ttfamily\color{green!80!black}},
% Style for sorts keywords
keywordstyle=[3]{\ttfamily\color{cyan}},
% Style for tactics keywords
keywordstyle=[4]{\ttfamily\color{blue}},
% Style for terminators keywords
keywordstyle=[5]{\ttfamily\color{red}},
%Style for iterators
%keywordstyle=[6]{\ttfamily\color{dkpink}},
% Style for strings
stringstyle=\ttfamily,
% Style for comments
commentstyle={\ttfamily\color{red!50!black}},
%
%moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
literate=
    {\\forall}{{\color{green!80!black}{$\forall\;$}}}1
    {\\exists}{{$\exists\;$}}1
    {<-}{{$\leftarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    %{==}{{\code{==}\;}}1
    {==>}{{\code{==>}\;}}1
%    {:>}{{\code{:>}\;}}1
    {->}{{$\rightarrow\;$}}1
    {<->}{{$\leftrightarrow\;$}}1
    {<==}{{$\leq\;$}}1
    {\#}{{$^\star$}}1 
    {\\o}{{$\circ\;$}}1 
    {\@}{{$\cdot$}}1 
    {\/\\}{{$\wedge\;$}}1
    {\\\/}{{$\vee\;$}}1
    %{++}{{\code{++}}}1
    {~}{{\ }}1
    {\@\@}{{$@$}}1
    {\\mapsto}{{$\mapsto\;$}}1
    {\\hline}{{\rule{\linewidth}{0.5pt}}}1
%
}[keywords,comments,strings]

\definecolor{mygrey}{rgb}{0.91,0.90,0.90}
\lstset{language=Coq,backgroundcolor=\color{mygrey}}
%\lstnewenvironment{coq-inline}{\lstinline{language=Coq}}{}


\title{Rapport de stage}
\author{Karim \bsc{Mamode} \and Arthure \bsc{Wenger}}
\date{Lundi 22 Mai 2017} % Delete this line to display the current date

%%% BEGIN DOCUMENT
\begin{document}

\maketitle
\tableofcontents
\setcounter{chapter}{-1}
% Introduction --------------------------------
\chapter{Introduction}
Ce document est un rapport du stage effectué dans le cadre de la 3\ieme\ année de licence informatique à l'Université de la Réunion.

Le but du stage est de démontrer formellement les propriétés de la thèse de Mandimby Nirina \bsc{Ranaivo} \bsc{Rakotondravelona}. Pour cela, nous avons utiliser le logiciel Coq.

Il y a eu deux phases dans notre travail. La première était une étape de modélisation. Cette étape consiste à transposer les différents éléments de la thèse en langage Coq. La deuxième phase, c'étaient les démonstrations en elle même.

Ce rapport présentera le travail effectué dans cet ordre. On aura une première partie qui expliquera comment nous avons modéliser en coq les régions, les routes et tout ce qui tourne autour. Dans une deuxième partie, on expliquera en langage naturel les démonstrations Coq que nous avons effectuées.
\part{La modélisation}
% Région -----------------------------------
\chapter{Les régions}
\section{Définition}
Une région a été définie comme suit :

\begin{lstlisting}
Inductive region : Type :=
| Z : region
| OO : region -> region
| OI : region -> region
| IO : region -> region
| II : region -> region.
\end{lstlisting}

\paragraph{Explication :}
Une région, c'est :
\begin{itemize}
\item Soit une région vide. C'est l'élément de base% à compléter
\item Soit une des 4 sous-régions d'une région.
\end{itemize}
\newpage
\paragraph{Exemple :}
Voici une région divisée en quatre sous-régions elle même divisée de la même façon.

\begin{figure}[h!]
\begin{center}
\includegraphics{Sous_region.jpg}
\end{center}
%\caption{Une région et ses sous régions}
\end{figure}
Sur cet exemple, la sous région grisée s'écrira sous la forme :\newline
\begin{lstlisting}
( IO ( II ( OO Z ) ) )
\end{lstlisting}
\paragraph{Comment le comprendre ?}
Ici, il faut lire que \lstinline{IO} est une sous région de \lstinline{( II ( OO Z ) )}
On note que ça se lit de droite à gauche. La sous-région la plus profonde est la plus à gauche. De même, dans cet exemple, la région \lstinline{( OO Z )} est la région qui englobe les autres régions filles.

Dans les fonctions qui vont suivre, la région vide \lstinline{Z} est considéré comme la région mère d'une région de niveau 1.
\paragraph{}
Ainsi, nous avons une modélisation d'une région. On peut alors faire diverse fonction sur ces dernières comme on le verra dans la suite.
\newpage
% Niveau de région ----------
\section{Le niveau d'une région}
\subsection{Calcule du niveau d'une région}
Pour calculer le niveau d'une région, nous avons défini la fonction suivante :
\begin{lstlisting}
Fixpoint rank (n:region) : nat :=
    match n with
    | Z => 0
    | OO n' | OI n' | IO n' | II n' => 1 + rank n'
    end.
\end{lstlisting}
\paragraph{Explication :}
Le niveau d'une région, c'est :
\begin{itemize}
\item Dans le cas d'une région vide, 0.
\item Dans le cas d'une région fille, c'est 1 + le niveau de la région mère.
\end{itemize}
\vspace{\baselineskip}
Ainsi, le code \lstinline{Eval compute in rank (II (OI Z)).} nous donne bien \lstinline{2}.
\subsection{Obtenir une région d'un certain niveau}
Pour obtenir une région de niveau \lstinline{n} contenant la région \lstinline{r}, nous avons défini la fonction suivante :
\begin{lstlisting}
Fixpoint region_at_rank (r:region) (n:nat) : region :=
    if Nat.eqb (rank r) n || Nat.eqb (rank r) 1 then
        r
    else
        match r with 
         | Z => Z
         | OO r' | OI r' | IO r' | II r' => region_at_rank r' n 
        end.
\end{lstlisting}
\paragraph{Explication :}
On renvoie la région \lstinline{r} dans deux cas :
\begin{itemize}
\item Soit quand le niveau de cette région est égal au niveau de région recherché, ça signifie alors qu'on a trouvé la bonne région à renvoyer.
\item Soit quand le niveau de la région est égal à 1 (et que le niveau recherché est différent de 1), ce qui signifie qu'on a recherché une région de niveau supérieur à celui de \lstinline{r} ou de niveau \lstinline{0}.
\end{itemize}
Si on est dans aucun de ces cas là, la région de niveau \lstinline{n} contenant \lstinline{r} c'est :
\begin{itemize}
\item Dans le cas où \lstinline{r} est vide, la région vide même, puisqu'on ne peut pas aller plus profondément.
\item Dans le cas d'une région fille, la région de niveau \lstinline{n} contenant la région mère.
\end{itemize}
\vspace{\baselineskip}
Ainsi, le code \lstinline{Eval compute in region_at_rank (OO (II (OI Z))) 2.} nous donne bien \lstinline{(II (OI Z))}.
\subsection{Comparaison : Niveaux égaux}
Nous avons défini une fonction qui compare si deux régions ont le même niveau :
\begin{lstlisting}
Fixpoint same_rank (n1 n2 : region) : bool :=
    rank (n1) == rank (n2).
\end{lstlisting}
Ainsi, le code \lstinline{Eval compute in same_rank (II(OI(OO Z))) (OO(II(II Z))).} nous donne bien \lstinline{true}.
%Région  égale -----------
\section{Comparaison : Régions égales}
Nous avons défini une fonction pour déterminer si deux régions sont égales ou non :
\begin{lstlisting}
Fixpoint equal_region (n m : region) : bool :=
    match n, m with
    | Z , Z => true
    | OO n' , OO m' => equal_region n' m'
    | OI n' , OI m' => equal_region n' m'
    | IO n' , IO m' => equal_region n' m'
    | II n' , II m' => equal_region n' m'
    | _, _ => false
    end.
\end{lstlisting}
\paragraph{Explication :}
\begin{itemize}
\item Si les deux régions sont vides, alors elles sont égales.
\item Si les deux régions sont des régions filles qui ont le même numéro, alors leur région mère définit leur égalité
\item Sinon, les deux régions ne sont pas égales.
\end{itemize}
\vspace{\baselineskip}
Ainsi, le code \lstinline{Eval compute in equal_region (II(OI(OO Z))) (OO(II(II Z))).} renverra \lstinline{false} tandis que le code \lstinline{Eval compute in equal_region (II(OI(OO Z))) (II(OI(OO Z))).} renverra \lstinline{true}.
%Première région -----------
\section{Première région}
Nous avons défini une fonction qui détermine la première région d'une région donnée, c'est à dire la région de niveau 1 qui contient la région donnée.
\begin{lstlisting}
Fixpoint first_region (n : region) : region :=
    match rank n with
    | 1 => n
    | _ => match n with 
           | Z => Z
           | OO n' => first_region n'
           | OI n' => first_region n'
           | IO n' => first_region n'
           | II n' => first_region n'
           end
    end.
\end{lstlisting}
\paragraph{Explication :}
\begin{itemize}
\item Si le niveau de la région est 1, alors on renvoie cette région.
\item Sinon :
	\begin{itemize}
	\item Si la région est vide, on renvoie la région vide.
	\item Si c'est une région fille, on renvoie la première région de la région mère.
	\end{itemize}
\end{itemize}
\vspace{\baselineskip}
Ainsi, le code \lstinline{Eval compute in first_region (II(OI(OO Z))).} nous donne comme résultat\lstinline{(OO Z)}.
%Dernière région -----------
\section{Dernière région}
Nous avons défini une fonction qui détermine la dernière région d'une région donné, c'est à dire la région fille de plus haut niveau.
\begin{lstlisting}
Fixpoint last_region (n : region) : region :=
    match n with 
    | Z => Z
    | OO n' => OO Z
    | OI n' => OI Z
    | IO n' => IO Z
    | II n' => II Z
    end.
\end{lstlisting}
\paragraph{Explication :}
\begin{itemize}
\item Si c'est une région vide, on renvoie une région vide
\item Si c'est une région fille, on la renvoie sans sa région mère (à part la région vide).
\end{itemize}
\vspace{\baselineskip}
Ainsi, le code \lstinline{Eval compute in last_region (II(OI(OO Z))).} nous donne comme résultat\lstinline{(II Z)}.
%Hiérarchie -------------------------------------
\chapter{Les hiérarchies de régions}
\section{Définition}
La première représentation des ensembles de régions que nous avons choisie est la forme hiérarchique. Nous l'avons défini comme suit :

\begin{lstlisting}
Inductive treeRegion :=
  | Leaf : region -> treeRegion
  | Node : region -> treeRegion -> treeRegion -> treeRegion -> treeRegion -> treeRegion.
\end{lstlisting}

\paragraph{Explication :}
La hiérarchie des régions, c'est :
\begin{itemize}
\item Soit une feuille de l'arbre contenant une région. Elle représente une région qui n'a pas de région fille.
\item Soit un noeud de degré 5 (ou quatre s'il est au sommet de la hiérarchie) représentant une région mère qui contient ses quatre régions filles.
\end{itemize}
Dans la suite, nous appelleront le type \lstinline{treeRegion} \lstinline{t} pour plus de facilité.
\newpage
\paragraph{Exemple :}
Voici une hiérarchie de 2 noeuds internes et 7 feuilles.

\begin{figure}[h!]
\begin{center}
\includegraphics{Hierarchie_region.jpg}
\end{center}
\end{figure}
Sur cet exemple, la hiérarchie s'écrira de la façon suivante :
\begin{lstlisting}
Node (OO Z) (Leaf (OO (OO Z)))
            (Leaf (OI (OO Z)))
            (Node (II (OO Z)) (Leaf (OO (II (OO Z))))
                              (Leaf (OI (II (OO Z))))
                              (Leaf (II (II (OO Z))))
                              (Leaf (IO (II (OO Z)))))
            (Leaf (IO (OO Z)))
\end{lstlisting}
\paragraph{Comment le comprendre ?}
Ici, il faut lire que la région \lstinline{(OO Z)} est la region mère des régions \lstinline{(OO (OO Z))}, \lstinline{(OI (OO Z))}, \lstinline{(II (OO Z))} et \lstinline{(IO (OO Z))}. La région \lstinline{(II (OO Z))} n'est pas une feuille mais un noeud interne de l'arbre car c'est la région mère des régions \lstinline{(OO (II (OO Z)))}, \lstinline{(OI (II (OO Z)))}, \lstinline{(II (II (OO Z)))} et \lstinline{(IO (II (OO Z)))}.

Dans la suite, nous utiliserons ce graphe comme référence dans les exemples.
\paragraph{}
Maintenant que nous avons défini la hiérarchie en arbre des régions, nous pouvons définir différentes fonctions sur celle-ci.
\newpage
% Hauteur de l'arbre ---------------
\section{La hauteur de l'arbre}
Pour calculer la hauteur d'un arbre, nous avons défini la fonction suivante :
\begin{lstlisting}
Fixpoint height (m : t) : nat :=
  match m with
  | Leaf _ => 0
  | Node _ l ml mr r => 1 + Nat.max (Nat.max (height l) (height ml))
                                    (Nat.max (height mr) (height r))
  end.
\end{lstlisting}
\paragraph{Explication :}
La hauteur d'un arbre, c'est :
\begin{itemize}
\item S'il s'agit d'une feuille, \lstinline{0}.
\item S'il s'agit d'un noeud interne, \lstinline{1} plus la hauteur maximum de ses sous-arbres.
\end{itemize}
\vspace{\baselineskip}
Ainsi, la fonction appliquée à notre arbre précédent renverra \lstinline{2}.
% Cardinal de l'arbre -----------
\section{Le cardinal de l'arbre}
Pour calculer le cardinal d'un arbre, nous avons défini la fonction suivante :
\begin{lstlisting}
Fixpoint cardinal (m : t) : nat :=
  match m with
   | Leaf _ => 1
   | Node _ l ml mr r => 1 + cardinal l + cardinal ml + cardinal mr + cardinal r
  end.
\end{lstlisting}
\paragraph{Explication :}
Le cardinal d'un arbre c'est :
\begin{itemize}
\item S'il s'agit d'une feuille, \lstinline{1}.
\item S'il s'agit d'un noeud interne, \lstinline{1} plus la somme des cardinaux de ses sous-arbres.
\end{itemize}
\vspace{\baselineskip}
Ainsi, la fonction appliquée à notre arbre précédent renverra \lstinline{9}.
\newpage
% Nombre de feuille ---------------
\section{Le nombre de feuille de l'arbre}
Pour calculer le nombre de feuille d'un arbre, nous avons défini la fonction suivante :
\begin{lstlisting}
Fixpoint cardinal_leaf (m : t) : nat :=
  match m with
   | Leaf _ => 1
   | Node _ l ml mr r => cardinal_leaf l + cardinal_leaf ml
                       + cardinal_leaf mr + cardinal_leaf r
  end.
\end{lstlisting}
\paragraph{Explication :}
Le nombre de feuille d'un arbre c'est :
\begin{itemize}
\item S'il s'agit d'une feuille, \lstinline{1}.
\item S'il s'agit d'un noeud interne, la somme du nombre de feuille de ses sous-arbres.
\end{itemize}
\vspace{\baselineskip}
Ainsi, la fonction appliquée à notre arbre précédent renverra \lstinline{7}.
% Liste de région --------------------------------
\chapter{Les listes de région}
\section{Définition d'une liste}
La deuxième représentation d'ensemble de régions que nous avons choisis est sous forme de liste.
Pour cela, nous avons défini un type \lstinline{clist}, qui construit des listes de n'importe quel type :
\begin{lstlisting}
Inductive clist (A:Type): Type :=
  | nil : clist A
  | cons : A -> clist A -> clist A.
\end{lstlisting}

\paragraph{Explication :}
Une liste, c'est :
\begin{itemize}
\item Soit une liste vide \lstinline{nil}
\item Soit un élément associé à une sous-liste.
\end{itemize}
\paragraph{Notation :}
Afin de faciliter l'écriture nous avons défini des notations standards, ainsi :
\begin{itemize}
\item \lstinline{(cons x l)} se notera \lstinline{x :: l}
\item \lstinline{(cons x .. (cons y nil) ..)} se notera \lstinline{[ x , .. , y ]}
\item la liste vide \lstinline{nil} se notera \lstinline{[ ]}
\end{itemize}
\paragraph{Exemple :\\}
Une liste d'entier \lstinline{(clist nat)}:
\begin{lstlisting}
[3, 1, 5, 2, 4]
\end{lstlisting}
Une liste de région \lstinline{(clist region)} :
\begin{lstlisting}
[OO Z, IO (OO Z), IO Z, OI (IO Z)]
\end{lstlisting}
Maintenant que les listes sont définies, on verra quelques fonctions utiles sur les listes.
% La taille de liste --------
\section{La taillle d'une liste}
Nous avons défini une fonction qui compte le nombre d'élément d'une liste :
\begin{lstlisting}
Fixpoint list_count {A:Type} (l:clist A) : nat := 
  match l with
  | nil => 0
  | cons n l' =>  1 + list_count l'
  end.
\end{lstlisting}
\paragraph{Explication :}
La taille d'une liste c'est :
\begin{itemize}
\item Si la liste est vide, 0.
\item Si la liste contient au moins un élément, 1 + la taille du reste de la liste.
\end{itemize}
\vspace{\baselineskip}
Ainsi, le code \lstinline{Eval compute in list_count [OO Z, IO(II Z), OO Z, IO Z].} donnera \lstinline{4}.
% Concaténation de listes ------------
\section{La concaténation de deux listes}
La concaténation de deux listes a été définie comme suit :
\begin{lstlisting}
Fixpoint concat_list {A:Type}(l1 l2:clist A): clist A :=
  match l1 with
  | nil => l2
  | cons n l' => cons n (concat_list l' l2)
  end.
\end{lstlisting}
\paragraph{Explication :}
La concaténation de deux listes, c'est :
\begin{itemize}
\item Si la première liste est vide, c'est simplement la deuxième liste.
\item Si la première liste est la construction d'un élément avec une sous liste, alors on construit un liste avec l'élément et la concaténation de la sous-liste avec la deuxième liste.
\end{itemize}
Dans la suite, nous noterons la concaténation \lstinline{++}. C'est à dire qu'au lieu de marquer \lstinline{(concat_list x y)}, nous noterons \lstinline{x ++ y}.

Ainsi, le code \lstinline{Eval compute in [OO Z,IO Z] ++ [OI Z,II Z].} donnera \lstinline{[OO Z,IO Z,OI Z,II Z]}.
% Récup' élém' dans liste ------------
\section{Récupération d'élément dans une liste}
Nous avons défini une fonction qui permet de récupérer un élément dans une liste :
\begin{lstlisting}
Fixpoint get_list_elm {A:Type}(l:clist A)(n:nat): option :=
  match l, n with
  | nil, _ => None
  | cons x l', 0 => Some x
  | cons x l', S n' => get_list_elm l' n'
  end.
\end{lstlisting}
\paragraph{Explication :}
L'élément récupéré dans la liste à la position \lstinline{n}, c'est :
\begin{itemize}
\item Si la liste est vide, rien.
\item Si l'index est à \lstinline{0}, c'est l'élément sur lequel on est.
\item Sinon, c'est l'élément récupéré dans le reste de la liste à la position \lstinline{n - 1}
\end{itemize}
Dans cette fonction, nous avons utilisé des options, c'est à dire que s'il n'y a pas de valeur à renvoyé, nous renvoyons \lstinline{None}, sinon, nous renvoyons le résultat (\lstinline{x}) sous la forme \lstinline{Some x}. Ce résultat ne correspond pas au type recherché (que ce soit un entier ou une région), pour extraire l'élément voulu (\lstinline{x}) de \lstinline{Some x}, on utilise la fonction suivante :
\begin{lstlisting}
Definition option_elim {A:Type} (default: A) (opt: option): A :=
  match opt with
  | Some n' => n'
  | None => default
  end. 
\end{lstlisting}
\paragraph{Explication :}
\begin{itemize}
\item Si l'option est de la forme \lstinline{Some n}, on renvoie \lstinline{n}
\item Si c'est \lstinline{None}, on renvoie la valeur par défaut passée en argument.
\end{itemize}
Afin d'alléger le code, nous avons défini une fonction qui extrait directement la région obtenue via \lstinline{get_list_elm}. Cette fonction renvoie la région vide si l'élément n'a pas été trouvé :
\begin{lstlisting}
Definition get_list_reg (l:clist region)(n:nat): region := option_elim Z (get_list_elm l n).
\end{lstlisting}
Ainsi, le code \lstinline{Eval compute in get_list_reg [OO Z,IO Z,II Z] 2.} donnera \lstinline{II Z}.
% Région dans liste ? -------------
\section{Présence d'une région dans une liste}
Nous avons déterminé une fonction qui vérifie si une région se trouve dans une liste de région donnée.
\begin{lstlisting}
Fixpoint is_in_list (l:clist region)(x:region): bool :=
  match l with
  | nil => false
  | cons n l' => if equal_region x n then
                  true
                 else
                  is_in_list l' x
  end.
\end{lstlisting}
Cette fonction ne s'applique qu'aux régions et listes de régions car nous n'avons pu créer une égalité pour des types polymorphe.
\paragraph{Explication :}
\begin{itemize}
\item Si la liste est vide, l'élément recherché n'est pas dans la liste.
\item Si la liste contient au moins une élément :
	\begin{itemize}
	\item Soit c'est bien l'élément qu'on recherche, alors l'élément est bien dans la liste.
	\item Soit on continue la recherche dans le reste de la liste.
	\end{itemize}
\end{itemize}
\vspace{\baselineskip}
Ainsi, le code \lstinline{Eval compute in is_in_list [OO Z,OI Z,IO Z] (II Z).} renverra \lstinline{false} et 	le code \lstinline{Eval compute in is_in_list [OO Z,OI Z,IO Z] (IO Z).} renverra \lstinline{true}.
\newpage
% Index région ----------
\section{Position d'une région dans une liste}
Nous avons défini une fonction qui permet de determiner la position (l'index) d'une région dans une liste :
\begin{lstlisting}
Fixpoint get_row_region (l:clist region)(x:region): option :=
  match l with
  | nil => None
  | cons n l' => if equal_region x n then
                   Some 0
                 else
                   add_opt (Some 1) (get_row_region l' x)
  end.
\end{lstlisting}
\paragraph{Explication :}
Pour la recherche de l'emplacement d'une région dans une liste, on procède de la façon suivante :
\begin{itemize}
\item Si la liste est vide, la région n'est pas présente dans la liste.
\item Sinon :
	\begin{itemize}
	\item Si la première région de la liste est égale à la région recherchée, alors on renvoie \lstinline{0}
	\item Sinon, on refait une recherche dans le reste de la liste et on ajoute 1 au résultat trouvé.
	\end{itemize}
\end{itemize}
Nous n'avons pas fait d'arithmétique directement sur les entiers mais sur des \lstinline{option nat}. En effet, nous avons défini la fonction suivante :
\begin{lstlisting}
Definition add_opt (a b:@option nat):@option nat :=
  match a, b with
  | Some a', Some b' => Some (a'+b')
  | _, _ => None
  end.
\end{lstlisting}
\paragraph{Explication :} Si deux \lstinline{option nat} sont de la forme \lstinline{Some x}, on en sort un nouvel \lstinline{option nat} dont l'entier est la somme des deux entiers. Dans tous les autres cas, on renvoie \lstinline{None}.

Ainsi, \lstinline{Eval compute in add_opt (Some 3) (Some 4).} renverra \lstinline{Some 7}.\\
Nous avons donc pu facilement additionner les retours de \lstinline{get_row_region}.

Ainsi, \lstinline{Eval compute in get_row_region [OO Z, IO Z, II Z] (II Z).} renverra \lstinline{2}.
\newpage
% Égalité de liste ----------
\section{Comparaison : listes égales}
Nous avons défini une fonction qui détermine si deux listes sont égales ou non de la façon suivante :
\begin{lstlisting}
Fixpoint equal_list_region (l1 l2:clist region): bool :=
  match l1, l2 with 
  | nil, nil => true
  | cons x1 l1', cons x2 l2' => if (equal_region x1 x2) then
                                  equal_list_region l1' l2' else false
  | _, _ => false
end.
\end{lstlisting}
\paragraph{Explication :}
\begin{itemize}
\item Si les deux listes sont vides, elles sont égales.
\item Si les deux listes ont au moins un élément, on compare le premier élément de chaque liste :
	\begin{itemize}
	\item Si les deux sont égaux, on compare le reste de la liste.
	\item Sinon, les deux listes ne sont pas égales.
	\end{itemize}
\item Dans tous les autres cas, les deux listes ne sont pas égales.
\end{itemize}
\vspace{\baselineskip}
Ainsi, le code \lstinline{Eval compute in equal_list_region [OO Z, II Z, IO Z] [OO Z, II Z, IO Z, II Z].} renverra \lstinline{false} tandis que \lstinline{Eval compute in equal_list_region [OO Z, II Z, IO Z] [OO Z, II Z, IO Z].} renverra \lstinline{true}.
% Matrices ----------------------------------------
\chapter{Les matrices de région}
La troisième représentation des régions est sous forme matricielle. En effet, selon la thèse, c'est l'une des représentation de l'organisation des régions.
% Liste de liste -------------
\section{Des listes de liste}
\subsection{Définition}
Pour pouvoir arriver à une représentation des matrices, nous devons d'abord définir des listes de liste.
\begin{lstlisting}
Inductive listlist (A:Type) : Type :=
  | lnil : listlist A
  | lcons : clist A -> listlist A -> listlist A.
\end{lstlisting}
\paragraph{Explication :}
Une liste de liste, c'est :
\begin{itemize}
\item Soit une liste vide. C'est une liste qui ne contient aucune liste.
\item Soit soit la construction d'une liste de type \lstinline{clist} avec une liste de liste (de type \lstinline{listlist}).
\end{itemize}
\paragraph{Notation :}
Afin de faciliter l'écriture nous avons défini des nouvelles notations ainsi :
\begin{itemize}
\item \lstinline{(lcons x .. (lcons y lnil) ..)} se notera \lstinline|'{ x , .. , y }|
\item la liste de liste vide \lstinline{lnil} se notera \lstinline|'{ }|
\end{itemize}
% Nombre de colonne --
\subsection{Nombre de colonne}
Nous avons ensuite défini le nombre de colonne d'une \lstinline{listlist}, c'est à dire le nombre de \lstinline{clist} que contient la \lstinline{listlist}.
\begin{lstlisting}
Fixpoint mat_count {A:Type}(m:listlist A): nat :=
  match m with
  | lnil => 0
  | lcons _ m' => 1 + mat_count m'
  end.
\end{lstlisting}
\paragraph{Explication :}
Le nombre de colonne d'une \lstinline{listlist}, c'est :
\begin{itemize}
\item Si la \lstinline{listlist} est vide, \lstinline{0}.
\item Si la \lstinline{listlist} est composée d'une \lstinline{clist} et d'une sous \lstinline{listlist}, \lstinline{1} plus le nombre de colonne de la sous \lstinline{listlist}.
\end{itemize}
% Concaténation --
\subsection{La concaténation de liste de liste}
Nous avons défini deux fonctions de concaténation de \lstinline{listlist}.
\subsubsection{Concaténation horizontale}
La première est la concaténation horizontale, c'est à dire qu'on ajoute les colonnes de la seconde \lstinline{listlist} à la suite des colonnes de la première \lstinline{listlist}.
\begin{lstlisting}
Fixpoint horcat {A:Type}(l1 l2:listlist A): listlist A :=
  match l1 with
  | lnil => l2
  | lcons v l' => lcons v (horcat l' l2)
  end.
\end{lstlisting}
\paragraph{Explication :}
La concaténation horizontale de deux \lstinline{listlist} :
\begin{itemize}
\item Si la première \lstinline{listlist} est vide, c'est la seconde \lstinline{listlist}.
\item Si la première \lstinline{listlist} est composée d'une \lstinline{clist} et d'une sous \lstinline{listlist}, on construit une nouvelle \lstinline{listlist} avec la \lstinline{clist} et la concaténation de la sous \lstinline{listlist} avec la seconde \lstinline{listlist}.
\end{itemize}
\subsubsection{Concaténation verticale}
La seconde concaténation est la concaténation verticale, c'est à dire qu'on ajoute les lignes de la seconde \lstinline{listlist} à la suite des lignes de la première \lstinline{listlist}.
\begin{lstlisting}
Fixpoint vertcat {A:Type}(m1 m2:listlist A): listlist A :=
  match m1, m2 with
  | lcons l1 m1', lcons l2 m2' => lcons (l1 ++ l2) (vertcat m1' m2')
  | lnil, _ => m2
  | _, lnil => m1
  end.
\end{lstlisting}
\paragraph{Explication :}
La concaténation verticale de deux \lstinline{listlist} :
\begin{itemize}
\item Si l'une des deux \lstinline{listlist} est vide, c'est l'autre \lstinline{listlist}.
\item Si les deux sont composées d'une \lstinline{clist} et d'une sous \lstinline{listlist}, on construit une nouvelle \lstinline{listlist} avec la concaténation des deux \lstinline{clist} et la concaténation verticale des deux sous \lstinline{listlist}.
\end{itemize}
% Les matrices ----------
\section{Les matrices}
\subsection{Vérification : est-ce une matrice ?} %%%%%%%%%%%%%%%
Une matrice, c'est une \lstinline{listlist} dont toutes les colonnes sont de taille égale. Nous avons donc défini une fonction qui vérifie si une liste de liste est bien une matrice :
\begin{lstlisting}
Fixpoint is_matrix {A:Type}(m:listlist A) : bool :=
  match m with
  | lnil => true
  | lcons l m' => match m' with
                  | lnil => true
                  | lcons l' m'' => Nat.eqb (list_count l) (list_count l')
                                    && is_matrix m''
                  end
  end.
\end{lstlisting}
\paragraph{Explication :}
\begin{itemize}
\item Si la \lstinline{listlist} est vide, alors c'est une matrice.
\item Si la \lstinline{listlist} est la construction d'une \lstinline{clist} et d'une sous \lstinline{listlist} :
	\begin{itemize}
	\item Si cette sous \lstinline{listlist} est vide, alors la \lstinline{listlist} est une matrice.
	\item Si cette sous \lstinline{listlist} est la construction d'une \lstinline{clist} et d'une sous \lstinline{listlist}, alors on vérfie si cette \lstinline{clist} et la première sont égales et si la sous \lstinline{listlist} est une matrice.
	\end{itemize}
\end{itemize}
\subsection{Vérification : est-ce une matrice carrée ?} %%%%%%%%%%%%%
Nous avons ensuite défini une fonction qui vérifie si une liste de liste est une matrice carrée :
\begin{lstlisting}
Definition is_square_matrix {A:Type}(m:listlist A) : bool :=
  match m with
  | lnil => true
  | lcons l' m' => (is_matrix m) && (Nat.eqb (list_count l') (mat_count m))
  end.
\end{lstlisting}
\paragraph{Explication :}
Si la liste de liste est vide, alors c'est une matrice carrée. Sinon, c'est une matrice carrée si la \lstinline{listlist} est une matrice et que son nombre de ligne est égale à son nombre de colonne. C'est à dire que la taille la \lstinline{listlist} est égale à la taille d'une des \lstinline{clist}.
% Récup élém listlist ---------
\section{Récupération d'élément dans une liste de liste}
\subsection{Récupération d'une colonne de liste de liste} %%%%%%%%%%%%%%%%%
Nous avons d'abord défini une fonction qui permet de récupérer une colonne d'une \lstinline{listlist} :
\begin{lstlisting}
Fixpoint get_col {A:Type}(m:listlist A)(n:nat): clist A :=
  match m, n with
  | lnil, _ => nil
  | lcons l m', 0 => l
  | lcons l m', S n' => get_col m' n'
  end.
\end{lstlisting}
\paragraph{Explication :}
la n\ieme\ colonne d'une \lstinline{listlist} c'est :
\begin{itemize}
\item Si la \lstinline{listlist} est nulle (\lstinline{lnil}), \lstinline{nil}.
\item Sinon :
	\begin{itemize}
	\item Si l'index est nul, c'est la colonne sur laquelle on se trouve.
	\item Sinon, c'est la (n-1)\ieme\ colonne dans la sous \lstinline{listlist}
	\end{itemize}
\end{itemize}
\subsection{Définition} %%%%%%%%%%%%%%%%%%%
Grâce à la fonction précédente, nous pouvons maintenant définir une fonction qui permet de récupérer un élément dans une liste de liste :
\begin{lstlisting}
Fixpoint get_mat_elm {A:Type}(m:listlist A)(row:nat)(col:nat): option :=
  get_list_elm (get_col m col) row.
\end{lstlisting}
\paragraph{Explication :}
On récupère l'élément à l'emplacement \lstinline{row} de \lstinline{col}\ieme\ colonne.

Afin de faciliter l'écriture, on écrira \lstinline{(get_mat_elm m r c)} de la façon suivante \lstinline{m _[ r , c ]}

De même que pour la récupération d'élément dans une liste, nous utilisons des options. Nous avons donc également défini une fonction qui extrait directement une région de l'option :
\begin{lstlisting}
Definition get_mat_reg (m:listlist region)(row:nat)(col:nat): region :=
  option_elim Z (get_mat_elm m row col).
\end{lstlisting}
\paragraph{Explication :} la région sera directement extraite de l'option récupéré par la recherche d'une région dans une \lstinline{listlist} de région. Si l'emplacement n'existe pas, l'option sera égale à \lstinline{None}, et donc notre fonction renverra la région vide.
% Partition --------------------------------------------
\chapter{Le partitionnement}
Maintenant que les matrices sont définies, accompagnées de plusieurs fonctions utilitaires, on va voir deux algorithmes de partitionnement des matrices : l'approche bottom-up et l'approche top-down.
% Préfixe ----------
\section{Ajout de préfixe...}
Avant cela, on doit définir une fonction qui permet d'ajouter un préfixe à toutes les régions d'un ensemble. C'est à dire que tous les éléments d'une liste ou d'une matrice auront une même nouvelle région fille.
\subsection{... à une liste} %%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}
Fixpoint prefix_list(r: region)(l:clist region): clist region :=
  match l with
  | nil => l
  | cons n l' => cons (concat_region r n) (prefix_list r l')  
  end.
\end{lstlisting}
\paragraph{Explication :}
Quand on ajoute un préfixe à une liste :
\begin{itemize}
\item Si la liste est vide, il n'y a rien à faire.
\item Si la liste est composée d'une région suivie d'une sous-liste, on construit une nouvelle liste avec la région concaténée à notre préfixe et l'ajout de préfixe à la sous-liste.
\end{itemize}
\vspace{\baselineskip}
Ainsi, le code \lstinline{Eval compute in prefix_list (II Z) [OO Z, IO Z].} renverra \lstinline{[II (OO Z), II (IO Z)]}
\subsection{... à une matrice} %%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}
Fixpoint prefix_mat(r: region)(m:listlist region): listlist region :=
  match m with
  | lnil => m
  | lcons v m' => lcons (prefix_list r v) (prefix_mat r m')
  end.
\end{lstlisting}
\paragraph{Explication :}
Quand on ajoute un préfixe à une matrice :
\begin{itemize}
\item Si elle est vide, il n'y a rien à faire.
\item Si elle est composée d'une liste de région suivie d'une sous-matrice, on construit une nouvelle matrice avec la liste concaténée à notre préfixe et l'ajout de préfixe à la sous-matrice.
\end{itemize}
\vspace{\baselineskip}
Ainsi, le code \lstinline|Eval compute in prefix_mat (II Z) '{[OO Z, IO Z],[OI Z]}.| renverra \lstinline|'{ [II (OO Z), II (IO Z)], [II (OI Z)]}|
% Suffixe ----------
\section{Ajout de suffixe...}
De façon similaire, nous avons défini deux fonctions qui ajoute des suffixes à des ensembles de région. C'est à dire que tous les éléments d'une liste ou d'une matrice auront une même nouvelle région mère.\\
Les définitions sont quasiment identique. La seule chose qui change, c'est l'ordre dans lequel on concatène le suffixe à une région.
\subsection{... à une liste} %%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}
Fixpoint suffix_list(r: region)(l:clist region): clist region :=
  match l with
  | nil => l
  | cons n l' => cons (concat_region n r) (suffix_list r l')  
  end.
\end{lstlisting}
\subsection{... à une matrice} %%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}
Fixpoint suffix_mat(r: region)(m:listlist region): listlist region :=
  match m with
  | lnil => m
  | lcons v m' => lcons (suffix_list r v) (suffix_mat r m')
  end.
\end{lstlisting}
\section{La rotation des régions}
Nous avons ensuite défini une petite fonction qui détermine le numéro local d'une région selon son niveau et son emplacement :
\begin{lstlisting}
Definition rot_nat (n : nat) : region -> region :=
  match n mod 4 with
  | 0 => OO
  | 1 => OI
  | 2 => II
  | 3 => IO
  | _ => OO
  end.
\end{lstlisting}
Cette définition correspond à la fonction f(x) de la partie partionnement de la fiche.
\section{Matrice de base}
Afin d'appliquer correctement l'algorithme de partitionnement, nous devons définir une fonction qui crée une matrice de base selon un niveau donné. C'est à dire une matrice carrée de dimension 2 définie de la façon suivante : \\
\[
\begin{pmatrix}
	f(n) & f(n + 1) \\
	f(n + 3) & f(n + 2)
\end{pmatrix}
\]
Avec \(f\) qui correspond à \lstinline{rot_nat} et \(n\) qui correspond au niveau de la région :
\begin{lstlisting}
Definition get_base_matrix(n:nat) : listlist region := 
'{[ (rot_nat n) Z, rot_nat (n+3) Z ], [(rot_nat (n+1)) Z, (rot_nat (n+2)) Z ] }.
\end{lstlisting}
\section{L'algorithme bottom-up}
Maintenant que nous avons notre matrice de base, nous pouvons élaborer l'algorithme bottom-up.
\paragraph{En quoi consiste cet algorithme ?} Le principe de cet algorithme est de partir d'une matrice de base de niveau n, puis de construire une matrice de base de niveau n-1 et de concaténer chacune de ses régions à la matrice de base de niveau n. On obtient ainsi une nouvelle matrice qui contient 4 fois plus d'éléments. Ensuite on réitère l'opération en construisant une matrice de base de niveau n-2 et en concaténant notre précédente matrice à chacune de ses quatre régions. On répète l'opération n fois au total, ce qui nous donne à la fin la matrice de partitionnement de niveau n.
\subsection{Définition}
Nous avons défini l'implémentation de la façon suivante :
\begin{lstlisting}
Definition mat_part_bup (n:nat)(r: region):listlist region :=
match n with
| O => '{[r]}
| S n' => suffix_mat r ((fix from_n_to_0 (n:nat)(m:listlist region):listlist region :=
          match n with
          | O => m
          | S n' => let base := get_base_matrix n' in (
                    from_n_to_0 n' (
                    vertcat (horcat (suffix_mat (option_elim Z (base _[0,0])) m)
                             (suffix_mat (option_elim Z (base _[0,1])) m ))
                             (horcat (suffix_mat (option_elim Z (base _[1,0])) m)
                             (suffix_mat (option_elim Z (base _[1,1])) m ))) )
          end) n' (get_base_matrix n'))
end.
\end{lstlisting}
\paragraph{Explication :} À FAIRE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\vspace{\baselineskip}

Ainsi, le code \lstinline{Eval compute in mat_part_bup 2 (OO Z).} donnera
\begin{lstlisting}
'{ [OI (OO (OO Z)), OO (OO (OO Z)), OI (IO (OO Z)), OO (IO (OO Z))],
   [II (OO (OO Z)), IO (OO (OO Z)), II (IO (OO Z)), IO (IO (OO Z))],
   [OI (OI (OO Z)), OO (OI (OO Z)), OI (II (OO Z)), OO (II (OO Z))],
   [II (OI (OO Z)), IO (OI (OO Z)), II (II (OO Z)), IO (II (OO Z))]}
\end{lstlisting}
\section{l'algorithme top-down}
\paragraph{En quoi consiste cet algorithme ?} Cet algorithme part d'une matrice de niveau n. On construit ensuite une matrice de base de niveau n + 1 et on la concatène à chacun des éléments de notre matrice précédente. On commence à 0 puis on applique l'algorithme autant de fois qu'on le souhaite pour obtenir notre matrice de partitionnement.
\subsection{De liste à matrice}
Pour mettre en place cet algorithme, nous devons d'abord définir une fonction qui permet de créer une matrice à partir d'une liste et d'un niveau donné :
\begin{lstlisting}
Fixpoint parse_list (l:clist region)(n:nat): listlist region :=
match l with
| nil => lnil
| cons r l' => vertcat (suffix_mat r (get_base_matrix n)) (parse_list l' n)
end.
\end{lstlisting}
\paragraph{Explication :}
\begin{itemize}
\item Si la liste est vide, on renvoie une matrice vide.
\item Si la liste est composé d'un élément et d'une sous-liste, on concatène l'élément à une matrice de base de niveau donné, et on concatène cette nouvelle matrice à l'application de la fonction sur la sous-liste.
\end{itemize}
\vspace{\baselineskip}
Ainsi, le code \lstinline{Eval compute in parse_list [OO (OO Z)] 0.} donnera\\ \lstinline|'{ [OO (OO (OO Z)), IO (OO (OO Z))], [OI (OO (OO Z)), II (OO (OO Z))]}|
\subsection{De partitionnement n à n+1}
Grâce à la fonction précédemment définie, nous pouvons définir une fonction qui permet de passer d'une matrice de partitionnement n à une matrice de partitionnement de niveau n+1 :
\begin{lstlisting}
Fixpoint parse_mat (m:listlist region)(n:nat): listlist region :=
  match m with
  | lnil => lnil
  | lcons v m' => horcat (parse_list v n) (parse_mat m' n)
  end.
\end{lstlisting}
\paragraph{Explication :}
\begin{itemize}
\item Si la matrice est vide, on renvoie une matrice vide.
\item Si la matrice est composée d'une liste et d'une sous-matrice, On transforme la liste en matrice via la fonction précédente puis on réitère la fonction sur la sous-matrice.
\end{itemize}
\vspace{\baselineskip}
Ainsi, le code \lstinline|Eval compute in parse_mat '{[OO Z, OI Z],[IO Z, II Z]} 0.| donnera :
\begin{lstlisting}
'{ [OO (OO Z), IO (OO Z), OO (OI Z), IO (OI Z)],
   [OI (OO Z), II (OO Z), OI (OI Z), II (OI Z)],
   [OO (IO Z), IO (IO Z), OO (II Z), IO (II Z)],
   [OI (IO Z), II (IO Z), OI (II Z), II (II Z)]}
\end{lstlisting}
\subsection{Définition}

\end{document}
